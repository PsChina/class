<!DOCTYPE html>
<html ng-app="app">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body ng-controller="main">
    {{ msg }}
    <mylink></mylink>
</body>
<script src="./angular.js"></script>
</html>
<script>
    angular.module('app',[])
            .controller('main',['$scope',function($scope){
                $scope.msg = 'Hello World!';
            }]) 
            .directive('mylink',[function(){ // link 你可以瞎写
                return{
                    template:'<div>学习link <sub-directive></sub-directive> </div>',
                    replace:true,
                    controller:['$scope',function($scope){
                        $scope.data = '嘻嘻嘻'
                    }],
                    link:function($scope,$element,$attribute){ // 加上replace:true 才有效
                        // link 的运行时机 是在编译之后 
                        // 上午 学 用自定义指令封装 功能和事件的 时候就学过了;
                        // 是一个简易的jQ对象
                        $element.css({background:'red'}).append('<h1>哈哈哈</h1>')
                        .append('<div>{{data}}</div>') 
                        // 它发生在 编译之后 所以编译者已经走了
                        // 像{{data}} 这种需要编译的东西 就不会有人来编译了
                        // 所以呢 它就原原本本的显示出来了
                        // 如果你想让他被编译你就不能在 link 里面写
                        // 只能在compile 里面写
                    },
                    compile:function($element,$attribute){ // 比link 要强大 它 有 各个阶段的函数 link函数只发生在编译之后

                        // 当compile 出现 link 将会被屏蔽 也就是说不生效
                        // 为什么不生效呢 因为 compile 包含了link 的所有功能 所以 compile存在的情况下 link 是多余的 对compile来说

                        // 编译之前
                        $element.append('<div>{{data}}</div>') 
                        console.log('编译之前')
                        // compile 有三个阶段 分别是 1 编译之前  2 子指令编译之前(父指令编译完毕) 3 完全编译

                        return {
                            pre:function($scope,$element,$attribute){ //子指令编译之前(父指令编译完毕)
                                console.log('父指令的pre')
                            },
                            post:function($scope,$element,$attribute){ //完全编译 就和我们的link 一样
                                console.log('父指令的post')
                               // 它是 link 
                            }
                        }                        

                    }
                }
            }]) 
            .directive('subDirective',[function(){
                return {
                    restrict:'ECMA',
                    template:'<div>{{data}}</div>',
                    controller:['$scope',function($scope){
                        $scope.data = '我是子指令'
                    }],
                    scope:{},
                    compile:function($element,$attribute){ 

                        console.log('子指令 编译之前')

                        return {
                            pre:function($scope,$element,$attribute){ //子指令编译之前(父指令编译完毕)
                                console.log('子指令的pre')
                            },
                            post:function($scope,$element,$attribute){ //完全编译 就和我们的link 一样
                                console.log('子指令的post')
                               // 它是 link 
                            }
                        }                        

                    }
                }
            }])
 

            // 什么是编译

            // 因为 浏览器 不是别 {{ }}  ng-click 这种东西
            // 他们只是别 class  和 onclick 这种原生的东西
            // 所以angular 有一套编译机制 专门负责把   {{ }}  ng-click 这种东西 转换成 原生的代码 也就是浏览器能识别的东西


            // 执行顺序
            // 1 从父级到子集 依次执行所有compile
            // 2 从父级到子集 依次执行所有 pre
            // 3 从子集到父级 一次执行所有 post
</script>