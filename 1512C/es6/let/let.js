//es6


/*
ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，
已经在 2015 年 6 月正式发布了。
它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。

es6更加面向对象

因为 面向对象的语言更容易维护

可以节约企业的开发成本 
*/





// 1 块级作用域内有效
// {
//     // 代码块
//     // 从第3行开始 到 第7行结束
//     let a = 10;
// }
// var i = 100;
// // var : 变量声明提升 undefined
//                  // let : i is not defined
// // console.log(a);
// var taskArr = []
// for (let i = 0 ; i < 5 ; i++){ // 当成一个 块级作用域 也就是代码块 就是block
//     taskArr.push( function(){
//         console.log(i) // i 是不是 不是我们的预期 我们想要的结果是 0 1 2 3 4
//     } )
// }

// console.log(i) 

// taskArr[0]()
// taskArr[1]()
// taskArr[2]()
// taskArr[3]()
// taskArr[4]()

// =>
// 5
// 5
// 5
// 5
// 5


// 2 不存在变量声明提升 

// 3 暂时性死区

// {
//     console.log(a); // 在不存在变量声明提升的同时 还存在一个 暂时性死区 
//     // 就是说 当你在一个作用域内 定义一个变量 之后 就不能在定义之前使用 这就是暂时性死区
//     /* temporal dead zone，简称 TDZ */
//     let a = 10; 
// }

// console.log(typeof a) 
// let a = 10;

// 4 不允许重复声明
// let a = 10;

// let a = 20;

// 5 块级作用域任意嵌套

// {
//     let a = 10;
    
//     {
//         let a = 100;
//         {
//             let a = 1000;
//             console.log('3',a)
//         }
//         console.log('2',a);
//     }
//     console.log('1',a);
// }

// 以上的a 每一个都是局部变量 => 块级作用域带来的局部变量


// 当函数声明提升遇到 块级作用域

{
    fn() // fn is not a function
    {
        function fn(){
            console.log('我是fn')
        }
    }
}

// 函数声明提升只能提升到块级作用域的顶部


// 1 cnost 命令 具有 let命令的所有特新

// 2 定义一个 指向不能被改变的量  内容能改变吗 如果是对象能改变内容 如果是 基本量 就不能改变



// let
// 1 不能变量提升

// 2 存在一个暂时性死区

// 3 不能重复声明变量

// 4 块级作用域 (是一个局部变量不是一个全局变量)

// 5 块级作用域任意嵌套

// const 

// 1 cnost 命令 具有 let命令的所有特新

// 2 定义一个 指向不能被改变的量  内容能改变吗 如果是对象能改变内容 如果是 基本量 就不能改变

// fn

// 函数声明提升只能提升到块级作用域的顶部


